#!/usr/bin/perl
#
# unpacks all file supporting recursive unpacking
# -samy kamkar 2020/11/01
#
# TODO:
#  - instead of ignoring files we already see, don't ignore files if their lastmod time changes (eg we unpacked pre-existing files)
#  - ignore files should recurse

use strict;
use Cwd;

die "usage: $0 [-v | -r] <files / paths ...>\n" unless @ARGV;
my $verbose = $ARGV[0] eq "-v" ? shift : 0;
my $recurse = $ARGV[0] eq "-r" ? shift : 0;

my %formats = (
  "asar"    => "asar extract FILE .",
  "bzip2"   => "bzip2 -vd FILE",
  "tar"     => "tar -xvf FILE",
  "cpio"    => "cpio -idv -F FILE",
  "xar"     => "xar -xv -f FILE",
  "gzip"    => "zcat -v FILE > FILE.unp",
  "7-zip"   => "7z x FILE",
  "lzma"    => "7z x FILE",
  "xz"      => "xz -vd FILE",
  "^zip"    => "unzip FILE",
  "dtb"     => "dtc -I dtb -O dts FILE -o FILE.dts", # ports/brew dtc
  "ramdisk" => "dumpimage -T ramdisk -o FILE.unp FILE", # brew uboot-tools (ports is broken)

  # linux version of dumpimage
  #"ramdisk" => "dumpimage -i FILE -T ramdisk FILE.unp",

  # untested
  "elf"     => "echo install binutils && echo readelf -a FILE",
  "exe"     => "objdump -x FILE",
  "macho"   => "macho_dump FILE",
);

# extensions to formats
# formats are already considered extensions, eg .asar is already considered asar but can be overridden here
my %exts = (
  "7z"   => "7-zip",
  "gz"   => "gzip",
  "tgz"  => "gzip",
  "bz2"  => "bzip2",
  "pkg"  => "xar",
  "pax"  => "cpio",
);

# this helps us ensure we're only looking at longer formats first - for example, match "7-zip" before "zip"
# alternatively, be verbose in %formats to prevent mismatches
my @formats = sort { length($b) <=> length($a) } keys %formats;

# files we still want to scan, use hash for speed
my %scan = map { $_ => 1 } @ARGV;
# let's skip the files that already exist in this dir
my %skip = map { $_ => 1 } grep { !$scan{$_} } <*>;

# traverse the files/dirs we passed in
find(@ARGV);
exit;

####

sub find
{
  foreach my $file (@_)
  {
    # skip specific paths
    next if $skip{$file};

    # skip pre-existing files
    debug("searching $file");
    my $shfile = shquote($file);
    -d $file ? ($recurse && find(<$shfile/*>)) : explode($file);
  }
}

sub explode
{
  foreach my $file (@_)
  {
    # skip files if we've already unpacked them
    next if $skip{$file}++;

    my $shfile = shquote($file);

    chomp(my $type = `file $shfile`);
    (undef, $type) = split(/:\s+/, $type, 2);
    print STDERR "< $file: $type\n";

    my $unpack = type($type, $file);
    debug("searching $file ($type)");
    if ($unpack)
    {
      # quote the file in case it has spaces/quotes
      $unpack =~ s/FILE/$shfile/g;
      print "> $unpack\n";
      system($unpack);

      # rescan unpacked files
      find(<*>) if $recurse;
    }
  }
}

sub type
{
  my ($type, $file) = @_;
  foreach my $format (keys %formats)
  {
    return $formats{$format} if $type =~ /$format/i
  }
  return $formats{$exts{$1} || $1} if $file =~ /\.([^.]+)$/;
}

sub debug
{
  print "$_[0]\n" if $verbose;
}

# quote file for shell
sub shquote
{
  (my $shfile = $_[0]) =~ s/'/'\\''/g;
  return "'$shfile'";
}

__DATA__
ramdisk => u-boot legacy uImage, , Linux/ARM 64-bit, RAMDisk Image (gzip), 1157194 bytes, Wed Nov 29 07:49:03 2023, Load Address: 0x00000000, Entry Point: 0x00000000, Header CRC: 0x4CB0B58F, Data CRC: 0x30EB577E
